class BankAccount {
    public final void generateAccountNumber() {
        System.out.println("Account number generated by Bank system.");
    }
}
// Subclass attempting to override final method
/*
class SavingsAccount extends BankAccount {
    // This will cause a compiler error
    public void generateAccountNumber() {
        System.out.println("Account number generated by SavingsAccount.");
    }
}
*/
public class A8 {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.generateAccountNumber();
    }
}
/*Observation:
A final method in Java means: It cannot be overridden in any subclass. This ensures that the method's behavior remains consistent and cannot be changed accidentally or intentionally. Useful when: You want to lock core business logic, such as account number generation, encryption, or ID creation. You want to enforce rules in all subclasses.

Conclusion:
Using final with methods is a way to protect essential functionality from being changed by subclasses. In this example, the bank ensures that all account numbers are generated consistently across all account types.*/
